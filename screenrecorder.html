<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Screen Recording and Saving</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --text-color: #ffffff;
            --button-bg: #2c2c2c;
            --button-hover: #3d3d3d;
            --accent-color: #4f46e5;  /* Updated to a modern indigo */
            --border-color: #333333;
            --error-color: #ef4444;
            --success-color: #22c55e;
            --warning-color: #f59e0b;
            --card-bg: #242424;
            --shadow-color: rgba(0, 0, 0, 0.2);
            
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            line-height: 1.5;
        }

        video {
            margin-top: 10px;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            max-width: min(90%, 800px);
            background-color: #000000;
            display: none;
        }

        video.active,
        #playbackVideo.active {
            display: block;
        }

        button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease;
            align-items: center;
            gap: 0.5rem;
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            color: var(--text-color);
        }

        button:hover:not(:disabled) {
            transform: translateY(-2px);
            background: var(--button-hover);
            box-shadow: 0 4px 12px var(--shadow-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .recording {
            animation: pulse 2s infinite;
            background-color: #dc3545 !important;
            color: white;
        }

        .history-item-actions button{

            box-shadow: inset 3px -2px 5px rgb(0 0 0 / 35%);
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.7; }
            100% { opacity: 1; }
        }

        #timer {
            font-size: 2rem;
            font-weight: 700;
            color: var(--accent-color);
            text-align: center;
        }

        .controls {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            justify-content: center;
            margin: 1.5rem 0;
        }

        .recording-indicator {
            display: none;
            color: #dc3545;
            margin: 10px;
            font-weight: bold;
            font-size: 14px;
            padding: 4px 8px;
            background: rgba(220, 53, 69, 0.1);
            border-radius: 4px;
        }

        .recording-indicator.active {
            display: inline-block;
        }

        .screen-select {
            background: var(--card-bg);
            border-radius: 1rem;
            padding: 1rem;
            margin: 1rem 0;
            display: none; /* Hide by default */
        }

        .screen-select.visible {
            display: block;
        }

        .screen-option {
            background: var(--button-bg);
            padding: 1rem;
            border-radius: 0.75rem;
            margin: 0.5rem;
            transition: all 0.2s ease;
            flex: 1;
            min-width: 150px;
            text-align: center;
            border: 1px solid var(--border-color);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .screen-option small {
            display: block;
            margin-top: 8px;
            opacity: 0.8;
            font-size: 0.8em;
        }

        .screen-option:hover {
            background-color: var(--accent-color);
            transform: translateY(-2px);
        }

        .loading {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 26, 26, 0.95);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .loading.visible {
            display: flex;
        }

        .spinner {
            width: 60px;
            height: 60px;
            margin: 0 auto 20px;
            border: 6px solid var(--border-color);
            border-top: 6px solid var(--accent-color);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        .loading p {
            font-size: 1.2em;
            margin: 0;
            color: var(--text-color);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .video-controls {
            max-width: min(90%, 800px);
            display: none;
            align-items: center;
            gap: 10px;
            background: var(--button-bg);
            padding: 10px;
            border-radius: 8px;
            width: 100%;  /* Add this */
            box-sizing: border-box;  /* Add this */
            margin: 0 auto;  /* Add this */
        }

        .video-controls.active {
            display: flex;
            width: 100%;  /* Add this */
            align-self: stretch;  /* Add this */
        }

        #seekBar {
            flex-grow: 1;
            height: 5px;
            cursor: pointer;
        }

        #currentTime, #duration {
            font-family: monospace;
            min-width: 45px;
        }

        .settings {
            margin: 10px 0;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        select {
            padding: 6px 12px;
            border-radius: 4px;
            background: var(--button-bg);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            font-size: 14px;
        }

        .file-size {
            margin: 5px 0;
            font-size: 0.9em;
            color: #888;
            padding: 4px 8px;
            background: var(--button-bg);
            border-radius: 4px;
            display: inline-block;
        }

        .save-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-color);
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            z-index: 1000;
            width: 90%;
            max-width: 400px;
            box-sizing: border-box;
        }

        .save-dialog.active {
            display: block;
        }

        .save-dialog input {
            width: 100%;
            padding: 8px 12px;
            margin: 10px 0;
            border-radius: 6px;
            border: 1px solid var(--border-color);
            background: var(--button-bg);
            color: var(--text-color);
            font-size: 14px;
            box-sizing: border-box;
        }

        .save-dialog .buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
        }

        .overlay.active {
            display: block;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .history-item {
            background: var(--button-bg);
            border-radius: 0.75rem;
            padding: 1.25rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .history-item-info {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .history-item-filename {
            font-weight: 600;
            font-size: 1.125rem;
        }

        .history-item-details {
            color: rgba(255, 255, 255, 0.7);
            font-size: 0.875rem;
            display: flex;
            gap: 15px;
        }

        .history-item-details span {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .history-item-details svg {
            width: 14px;
            height: 14px;

        }

        .history-item-actions {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        #playPauseBtn {
            background-color: var(--accent-color);
            padding: 12px;
            font-weight: bold;
            transition: all 0.2s ease;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
        }

        #playPauseBtn svg {
            width: 16px;
            height: 16px;
            fill: white;
            transition: all 0.2s ease;
        }

        #playPauseBtn.playing {
            background-color: #dc3545;
        }

        #playPauseBtn.playing:hover {
            background-color: #c82333;
        }

        #playPauseBtn:not(.playing) {
            background-color: #28a745;
        }

        #playPauseBtn:not(.playing):hover {
            background-color: #218838;
        }

        #playPauseBtn:hover {
            transform: scale(1.05);
        }

        #playPauseBtn:active {
            transform: scale(0.95);
        }

        .history-item-actions button {
            background: none;
            border: none;
            padding: 8px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .history-item-actions button:hover {
            transform: scale(1.1);
        }

        .history-item-actions button svg {
            width: 20px;
            height: 20px;
            fill: currentColor;
        }

        .history-item-actions .play-btn {
            color: #28a745;
        }

        .history-item-actions .play-btn:hover {
            background-color: rgba(40, 167, 69, 0.1);
        }

        .history-item-actions .delete-btn {
            color: #dc3545;
        }

        .history-item-actions .delete-btn:hover {
            background-color: rgba(220, 53, 69, 0.1);
        }

        .history-header h2::before {
            content: '▼';
            font-size: 0.8em;
            transition: transform 0.3s ease;
        }

        .history-header.collapsed h2::before {
            transform: rotate(-90deg);
        }

        .history-header.collapsed + .delete-all-btn {
            opacity: 0;
            pointer-events: none;
        }

        .recording-history {
            margin-top: 20px;
            width: 100%;
            max-width: 800px;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
            z-index: 9999;
            position: relative;
        }

        .history-header h2 {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .history-header h2::before {
            content: '▼';
            font-size: 0.8em;
            transition: transform 0.3s ease;
        }

        .history-header.collapsed h2::before {
            transform: rotate(-90deg);
        }

        .history-list {
            transition: height 0.3s ease;
            overflow: hidden;
        }

        .history-list.collapsed {
            height: 0 !important;
        }

        .delete-all-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background-color: var(--button-bg);
            color: #dc3545;
            border: 1px solid #dc3545;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s ease;
            display: none;
            opacity: 1;
            transition: opacity 0.3s ease;
        }

        .delete-all-btn.visible {
            display: flex;
        }

        .delete-all-btn:hover {
            background-color: rgba(220, 53, 69, 0.1);
            transform: translateY(-1px);
        }

        .delete-all-btn svg {
            width: 16px;
            height: 16px;
            stroke: currentColor;
        }

        .history-controls {
            display: flex;
            justify-content: flex-end;
            margin-bottom: 15px;
            padding: 0 15px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 1rem;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            height: auto;
            min-height: calc(100vh - 80px);
        }

        .recording-column {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            overflow-y: auto;
            overflow-x: hidden; /* Add this to prevent horizontal scroll */
            max-height: 100%;
            padding-right: 10px;
            padding-left: 10px;
            width: 100%; /* Add this to ensure proper width */
            box-sizing: border-box; /* Add this to include padding in width calculation */
        }

        .playback-column {
            flex: 1;
            min-width: 0;
            display: flex;
            flex-direction: column;
            max-height: 100%;
            padding-right: 10px;
            gap: 20px;
            overflow-y: hidden;
            align-items: center;  /* Add this */
            width: 100%;  /* Add this */
        }

        .recording-history {
            margin-top: 0;
            width: 100%;
            overflow-y: auto;
            flex: 1;
        }

        #screenVideo {
            max-width: 100%;
        }

        #playbackVideo {
            max-width: 100%;
            display: none;
            border: 2px solid var(--border-color);
            border-radius: 8px;
            background-color: #000000;
            order: -1;
            flex-shrink: 0;
        }

        #playbackVideo.active {
            display: block;
        }

        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
                height: auto;
                min-height: calc(100vh - 100px);
            }
            
            .recording-column,
            .playback-column {
                width: 100%;
            }

            .playback-column {
                height: 100%;
                max-height: 100%;
                display: grid;
                grid-template-rows: auto auto 1fr;
                gap: 20px;
            }

            #playbackVideo {
                width: 100%;
                max-height: 40vh;
                order: -1;
            }

            .video-controls {
                width: 100%;
                order: -1;
            }

            .recording-history {
                overflow-y: auto;
                max-height: calc(60vh - 100px);
                min-height: 200px;
            }
        }

        .controls button {
            align-items: center;
            gap: 8px;
        }

        .controls button svg {
            width: 16px;
            height: 16px;
            fill: currentColor;
           vertical-align: bottom;
        }

        .recording svg {
            animation: recordPulse 2s infinite;
        }

        @keyframes recordPulse {
            0% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.6;
                transform: scale(0.9);
            }
            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        .controls button#toggleVideo svg {
            display: none;
        }

        .controls button#toggleVideo svg.active {
            display: inline-block;
        }

        .recording-column::-webkit-scrollbar,
        .playback-column::-webkit-scrollbar,
        .recording-history::-webkit-scrollbar {
            width: 8px;
        }

        .recording-column::-webkit-scrollbar-track,
        .playback-column::-webkit-scrollbar-track,
        .recording-history::-webkit-scrollbar-track {
            background: var(--bg-color);
        }

        .recording-column::-webkit-scrollbar-thumb,
        .playback-column::-webkit-scrollbar-thumb,
        .recording-history::-webkit-scrollbar-thumb {
            background: var(--border-color);
            border-radius: 4px;
        }

        .recording-column::-webkit-scrollbar-thumb:hover,
        .playback-column::-webkit-scrollbar-thumb:hover,
        .recording-history::-webkit-scrollbar-thumb:hover {
            background: var(--button-hover);
        }

        body > h1 {
            margin: 20px 0px 10px 0px;
            text-align: center;
        }

        .video-controls {
            order: -1;
            flex-shrink: 0;
        }

        .save-dialog .filename-container {
            display: flex;
            align-items: center;
            gap: 4px;
            margin: 10px 0;
            width: 100%;
            background: var(--button-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 0 4px;
        }

        .save-dialog .filename-container input {
            flex: 1;
            border: none;
            background: none;
            margin: 0;
            padding: 8px;
        }

        .save-dialog .extension {
            color: var(--text-color);
            opacity: 0.7;
            padding: 8px 4px;
            user-select: none;
        }

        .history-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 15px;
            position: sticky;
            top: 0;
            background-color: var(--bg-color);
            z-index: 100;
            gap: 15px;
        }

        .delete-all-btn.visible {
            display: flex;
        }

        .history-header {
            cursor: pointer;
            user-select: none;
            z-index: 9999;
            position: relative;
        }

        .history-header h2 {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 0;
        }

        .history-header.collapsed + .delete-all-btn {
            opacity: 0;
            pointer-events: none;
        }

        /* Add padding to the history list to prevent content from going under sticky header */
        .history-list {
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding-top: 15px;
        }

        .storage-info {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-right: 15px;
            min-width: 150px;
        }

        .storage-text {
            font-size: 0.9em;
            color: var(--text-color);
            opacity: 0.8;
            text-align: center;
        }

        .storage-bar {
            height: 0.375rem;
            border-radius: 0.25rem;
            overflow: hidden;
        }

        .storage-fill {
            height: 100%;
            background: var(--accent-color);
            width: 0%;
            transition: width 0.3s ease, background-color 0.3s ease;
        }

        button#toggleVideo {
            transition: all 0.3s ease;
        }

        button#toggleVideo.showing {
            background-color: #dc3545;
        }

        button#toggleVideo.showing:hover {
            background-color: #c82333;
        }

        button#toggleVideo svg {
            display: none;
        }

        button#toggleVideo svg.active {
            display: inline-block;
        }

        .video-container {
            position: relative;
            display: none;
            order: -1;
            flex-shrink: 0;
            width: 100%;  /* Add this */
            max-width: min(90%, 800px);  /* Add this */
        }

        .video-container.active {
            display: block;
        }

        .close-video-btn {
            position: absolute;
            top: 40px;
            right: 0px;
            background: rgb(164 164 164 / 48%);
            border: none;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            z-index: 10;
            padding: 0;
        }

        .close-video-btn:hover {
            background: rgba(0, 0, 0, 0.8);
            transform: scale(1.1);
        }

        .close-video-btn svg {
            width: 20px;
            height: 20px;
        }

        /* Add/modify these styles for better mobile responsiveness */

        /* Base container adjustments */
        .container {
            display: flex;
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            gap: 20px;
            padding: 10px;
            box-sizing: border-box;
            height: calc(100vh - 80px);
        }

        /* Adjust controls for mobile */
        .controls {
            margin: 8px 0;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
            max-width: 400px;
            gap: 8px;
            padding: 0 10px;
        }


        .history-item-details {
            flex-wrap: wrap;
            gap: 10px;
        }

        .history-item-actions {
            width: 100%;
            justify-content: flex-end;
            margin-top: -50px;
        }

        /* Add responsive media queries */
        @media (max-width: 1200px) {
            .container {
                flex-direction: column;
                height: auto;
                min-height: calc(100vh - 80px);
                padding: 10px;
            }
            
            .recording-column,
            .playback-column {
                width: 100%;
                padding-left: 10px;
            }

            .playback-column {
                height: auto;
                max-height: none;
                display: grid;
                grid-template-rows: auto auto 1fr;
                gap: 15px;
                display: flex;
        align-items: center;
            }

            #playbackVideo {
                width: 100%;
                max-height: 40vh;
                order: -1;
            }

            .video-controls {
                width: 100%;
                order: -1;
                padding: 8px;
            }

            .recording-history {
                overflow-y: auto;
                max-height: 50vh;
                min-height: 200px;
            }
        }

        @media (max-width: 768px) {
            body {
                padding: 5px;
            }

            body > h1 {
                font-size: 24px;
                margin: 15px 10px;
            }

            #timer {
                font-size: 20px;
            }

            .history-item-details {
                font-size: 0.75em;
                flex-direction: column;
                gap: 5px;
            }

            

            .storage-info {
                width: 100%;
                min-width: 0;
            }

            .delete-all-btn {
                width: 100%;
                justify-content: center;
            }

            #seekBar {
                width: 100%;
                margin: 10px 0;
            }

            .save-dialog {
                width: 95%;
                padding: 15px;
            }
    
        }

        @media (max-width: 520px) {
            .screen-select .controls {
                flex-direction: column;
            }

            .screen-option {
                width: 100%;
                min-width: 0;
            }

            .history-item-actions button {
                padding: 6px;
            }

            .history-item-actions button svg {
                width: 18px;
                height: 18px;
            }

            .controls button {
                padding: 6px 12px;
                font-size: 13px;
            }

            #timer {
                font-size: 18px;
            }
            .history-item-info {

                font-size: .75em;
            }
            .history-top {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
                      /* Adjust history items for mobile */
        .history-item {
            flex-direction: column;
            gap: 10px;
        }

        .history-item-actions {
            margin-top: -50px;


        }

        .history-item-filename {
            font-size: .8em;
        }
        .history-item-details {

            font-size: .5em;
        }
        }

        

        /* Add touch-friendly adjustments */
        @media (hover: none) {
            button:hover:not(:disabled) {
                transform: none;
            }

            .history-item-actions button:hover {
                transform: none;
            }

            .screen-option:hover {
                transform: none;
            }

            /* Increase touch targets */
            .history-item-actions button {
                min-width: 44px;
                min-height: 44px;
            }

            .controls button {
                min-height: 44px;
            }
        }

        /* Add/modify media query for mobile */
        @media (max-width: 768px) {
            .recording-column {
                padding-right: 0; /* Remove right padding on mobile */
                width: 100%;
                max-width: 100vw; /* Ensure it doesn't exceed viewport width */
            }

            .controls {
                width: 100%;
                padding: 0 5px; /* Reduce padding on mobile */
                box-sizing: border-box;
            }

            /* Ensure all direct children of recording-column don't overflow */
            .recording-column > * {
                max-width: 100%;
                box-sizing: border-box;
            }
        }

        /* Add this CSS for the download button */
        .download-btn {
            background-color: #28a745;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        .download-btn:hover {
            background-color: #218838;
        }

        /* Add these styles in the <style> section */

        .video-title {
            text-align: center;
            margin-bottom: 10px;
            font-weight: 600;
            font-size: 1.1em;
            display: none;
        }

        .video-title.active {
            display: block;
        }

        .history-item.playing {
            border: 2px solid var(--accent-color);
            background: rgba(79, 70, 229, 0.1);
        }

        .history-item.playing .play-btn {
            background-color: var(--accent-color) !important;
            color: white !important;
        }

        /* Add this to the existing <style> section */
        @keyframes recordingBorder {
            0% {
                box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.8);
            }
            50% {
                box-shadow: 0 0 0 4px rgba(220, 53, 69, 0.4);
            }
            100% {
                box-shadow: 0 0 0 2px rgba(220, 53, 69, 0.8);
            }
        }

        video#screenVideo.recording {
            border: 2px solid #dc3545;
            animation: recordingBorder 2s infinite;
            border-radius: 8px;
        }
    </style>
    <!-- Add this in the <head> section, right after your existing scripts -->
    <script>(function (name, definition) {
        if (typeof define === 'function' && define.amd) { // RequireJS / AMD
            define(definition);
        } else if (typeof module !== 'undefined' && module.exports) { // CommonJS / Node.js
            module.exports = definition();
        } else { // Direct include
            window.ysFixWebmDuration = definition();
        }
    })('fix-webm-duration', function () {
        /*
         * This is the list of possible WEBM file sections by their IDs.
         * Possible types: Container, Binary, Uint, Int, String, Float, Date
         */
        var sections = {
            0xa45dfa3: { name: 'EBML', type: 'Container' },
            0x286: { name: 'EBMLVersion', type: 'Uint' },
            0x2f7: { name: 'EBMLReadVersion', type: 'Uint' },
            0x2f2: { name: 'EBMLMaxIDLength', type: 'Uint' },
            0x2f3: { name: 'EBMLMaxSizeLength', type: 'Uint' },
            0x282: { name: 'DocType', type: 'String' },
            0x287: { name: 'DocTypeVersion', type: 'Uint' },
            0x285: { name: 'DocTypeReadVersion', type: 'Uint' },
            0x6c: { name: 'Void', type: 'Binary' },
            0x3f: { name: 'CRC-32', type: 'Binary' },
            0xb538667: { name: 'SignatureSlot', type: 'Container' },
            0x3e8a: { name: 'SignatureAlgo', type: 'Uint' },
            0x3e9a: { name: 'SignatureHash', type: 'Uint' },
            0x3ea5: { name: 'SignaturePublicKey', type: 'Binary' },
            0x3eb5: { name: 'Signature', type: 'Binary' },
            0x3e5b: { name: 'SignatureElements', type: 'Container' },
            0x3e7b: { name: 'SignatureElementList', type: 'Container' },
            0x2532: { name: 'SignedElement', type: 'Binary' },
            0x8538067: { name: 'Segment', type: 'Container' },
            0x14d9b74: { name: 'SeekHead', type: 'Container' },
            0xdbb: { name: 'Seek', type: 'Container' },
            0x13ab: { name: 'SeekID', type: 'Binary' },
            0x13ac: { name: 'SeekPosition', type: 'Uint' },
            0x549a966: { name: 'Info', type: 'Container' },
            0x33a4: { name: 'SegmentUID', type: 'Binary' },
            0x3384: { name: 'SegmentFilename', type: 'String' },
            0x1cb923: { name: 'PrevUID', type: 'Binary' },
            0x1c83ab: { name: 'PrevFilename', type: 'String' },
            0x1eb923: { name: 'NextUID', type: 'Binary' },
            0x1e83bb: { name: 'NextFilename', type: 'String' },
            0x444: { name: 'SegmentFamily', type: 'Binary' },
            0x2924: { name: 'ChapterTranslate', type: 'Container' },
            0x29fc: { name: 'ChapterTranslateEditionUID', type: 'Uint' },
            0x29bf: { name: 'ChapterTranslateCodec', type: 'Uint' },
            0x29a5: { name: 'ChapterTranslateID', type: 'Binary' },
            0xad7b1: { name: 'TimecodeScale', type: 'Uint' },
            0x489: { name: 'Duration', type: 'Float' },
            0x461: { name: 'DateUTC', type: 'Date' },
            0x3ba9: { name: 'Title', type: 'String' },
            0xd80: { name: 'MuxingApp', type: 'String' },
            0x1741: { name: 'WritingApp', type: 'String' },
            // 0xf43b675: { name: 'Cluster', type: 'Container' },
            0x67: { name: 'Timecode', type: 'Uint' },
            0x1854: { name: 'SilentTracks', type: 'Container' },
            0x18d7: { name: 'SilentTrackNumber', type: 'Uint' },
            0x27: { name: 'Position', type: 'Uint' },
            0x2b: { name: 'PrevSize', type: 'Uint' },
            0x23: { name: 'SimpleBlock', type: 'Binary' },
            0x20: { name: 'BlockGroup', type: 'Container' },
            0x21: { name: 'Block', type: 'Binary' },
            0x22: { name: 'BlockVirtual', type: 'Binary' },
            0x35a1: { name: 'BlockAdditions', type: 'Container' },
            0x26: { name: 'BlockMore', type: 'Container' },
            0x6e: { name: 'BlockAddID', type: 'Uint' },
            0x25: { name: 'BlockAdditional', type: 'Binary' },
            0x1b: { name: 'BlockDuration', type: 'Uint' },
            0x7a: { name: 'ReferencePriority', type: 'Uint' },
            0x7b: { name: 'ReferenceBlock', type: 'Int' },
            0x7d: { name: 'ReferenceVirtual', type: 'Int' },
            0x24: { name: 'CodecState', type: 'Binary' },
            0x35a2: { name: 'DiscardPadding', type: 'Int' },
            0xe: { name: 'Slices', type: 'Container' },
            0x68: { name: 'TimeSlice', type: 'Container' },
            0x4c: { name: 'LaceNumber', type: 'Uint' },
            0x4d: { name: 'FrameNumber', type: 'Uint' },
            0x4b: { name: 'BlockAdditionID', type: 'Uint' },
            0x4e: { name: 'Delay', type: 'Uint' },
            0x4f: { name: 'SliceDuration', type: 'Uint' },
            0x48: { name: 'ReferenceFrame', type: 'Container' },
            0x49: { name: 'ReferenceOffset', type: 'Uint' },
            0x4a: { name: 'ReferenceTimeCode', type: 'Uint' },
            0x2f: { name: 'EncryptedBlock', type: 'Binary' },
            0x654ae6b: { name: 'Tracks', type: 'Container' },
            0x2e: { name: 'TrackEntry', type: 'Container' },
            0x57: { name: 'TrackNumber', type: 'Uint' },
            0x33c5: { name: 'TrackUID', type: 'Uint' },
            0x3: { name: 'TrackType', type: 'Uint' },
            0x39: { name: 'FlagEnabled', type: 'Uint' },
            0x8: { name: 'FlagDefault', type: 'Uint' },
            0x15aa: { name: 'FlagForced', type: 'Uint' },
            0x1c: { name: 'FlagLacing', type: 'Uint' },
            0x2de7: { name: 'MinCache', type: 'Uint' },
            0x2df8: { name: 'MaxCache', type: 'Uint' },
            0x3e383: { name: 'DefaultDuration', type: 'Uint' },
            0x34e7a: { name: 'DefaultDecodedFieldDuration', type: 'Uint' },
            0x3314f: { name: 'TrackTimecodeScale', type: 'Float' },
            0x137f: { name: 'TrackOffset', type: 'Int' },
            0x15ee: { name: 'MaxBlockAdditionID', type: 'Uint' },
            0x136e: { name: 'Name', type: 'String' },
            0x2b59c: { name: 'Language', type: 'String' },
            0x6: { name: 'CodecID', type: 'String' },
            0x23a2: { name: 'CodecPrivate', type: 'Binary' },
            0x58688: { name: 'CodecName', type: 'String' },
            0x3446: { name: 'AttachmentLink', type: 'Uint' },
            0x1a9697: { name: 'CodecSettings', type: 'String' },
            0x1b4040: { name: 'CodecInfoURL', type: 'String' },
            0x6b240: { name: 'CodecDownloadURL', type: 'String' },
            0x2a: { name: 'CodecDecodeAll', type: 'Uint' },
            0x2fab: { name: 'TrackOverlay', type: 'Uint' },
            0x16aa: { name: 'CodecDelay', type: 'Uint' },
            0x16bb: { name: 'SeekPreRoll', type: 'Uint' },
            0x2624: { name: 'TrackTranslate', type: 'Container' },
            0x26fc: { name: 'TrackTranslateEditionUID', type: 'Uint' },
            0x26bf: { name: 'TrackTranslateCodec', type: 'Uint' },
            0x26a5: { name: 'TrackTranslateTrackID', type: 'Binary' },
            0x60: { name: 'Video', type: 'Container' },
            0x1a: { name: 'FlagInterlaced', type: 'Uint' },
            0x13b8: { name: 'StereoMode', type: 'Uint' },
            0x13c0: { name: 'AlphaMode', type: 'Uint' },
            0x13b9: { name: 'OldStereoMode', type: 'Uint' },
            0x30: { name: 'PixelWidth', type: 'Uint' },
            0x3a: { name: 'PixelHeight', type: 'Uint' },
            0x14aa: { name: 'PixelCropBottom', type: 'Uint' },
            0x14bb: { name: 'PixelCropTop', type: 'Uint' },
            0x14cc: { name: 'PixelCropLeft', type: 'Uint' },
            0x14dd: { name: 'PixelCropRight', type: 'Uint' },
            0x14b0: { name: 'DisplayWidth', type: 'Uint' },
            0x14ba: { name: 'DisplayHeight', type: 'Uint' },
            0x14b2: { name: 'DisplayUnit', type: 'Uint' },
            0x14b3: { name: 'AspectRatioType', type: 'Uint' },
            0xeb524: { name: 'ColourSpace', type: 'Binary' },
            0xfb523: { name: 'GammaValue', type: 'Float' },
            0x383e3: { name: 'FrameRate', type: 'Float' },
            0x61: { name: 'Audio', type: 'Container' },
            0x35: { name: 'SamplingFrequency', type: 'Float' },
            0x38b5: { name: 'OutputSamplingFrequency', type: 'Float' },
            0x1f: { name: 'Channels', type: 'Uint' },
            0x3d7b: { name: 'ChannelPositions', type: 'Binary' },
            0x2264: { name: 'BitDepth', type: 'Uint' },
            0x62: { name: 'TrackOperation', type: 'Container' },
            0x63: { name: 'TrackCombinePlanes', type: 'Container' },
            0x64: { name: 'TrackPlane', type: 'Container' },
            0x65: { name: 'TrackPlaneUID', type: 'Uint' },
            0x66: { name: 'TrackPlaneType', type: 'Uint' },
            0x69: { name: 'TrackJoinBlocks', type: 'Container' },
            0x6d: { name: 'TrackJoinUID', type: 'Uint' },
            0x40: { name: 'TrickTrackUID', type: 'Uint' },
            0x41: { name: 'TrickTrackSegmentUID', type: 'Binary' },
            0x46: { name: 'TrickTrackFlag', type: 'Uint' },
            0x47: { name: 'TrickMasterTrackUID', type: 'Uint' },
            0x44: { name: 'TrickMasterTrackSegmentUID', type: 'Binary' },
            0x2d80: { name: 'ContentEncodings', type: 'Container' },
            0x2240: { name: 'ContentEncoding', type: 'Container' },
            0x1031: { name: 'ContentEncodingOrder', type: 'Uint' },
            0x1032: { name: 'ContentEncodingScope', type: 'Uint' },
            0x1033: { name: 'ContentEncodingType', type: 'Uint' },
            0x1034: { name: 'ContentCompression', type: 'Container' },
            0x254: { name: 'ContentCompAlgo', type: 'Uint' },
            0x255: { name: 'ContentCompSettings', type: 'Binary' },
            0x1035: { name: 'ContentEncryption', type: 'Container' },
            0x7e1: { name: 'ContentEncAlgo', type: 'Uint' },
            0x7e2: { name: 'ContentEncKeyID', type: 'Binary' },
            0x7e3: { name: 'ContentSignature', type: 'Binary' },
            0x7e4: { name: 'ContentSigKeyID', type: 'Binary' },
            0x7e5: { name: 'ContentSigAlgo', type: 'Uint' },
            0x7e6: { name: 'ContentSigHashAlgo', type: 'Uint' },
            0xc53bb6b: { name: 'Cues', type: 'Container' },
            0x3b: { name: 'CuePoint', type: 'Container' },
            0x33: { name: 'CueTime', type: 'Uint' },
            0x37: { name: 'CueTrackPositions', type: 'Container' },
            0x77: { name: 'CueTrack', type: 'Uint' },
            0x71: { name: 'CueClusterPosition', type: 'Uint' },
            0x70: { name: 'CueRelativePosition', type: 'Uint' },
            0x32: { name: 'CueDuration', type: 'Uint' },
            0x1378: { name: 'CueBlockNumber', type: 'Uint' },
            0x6a: { name: 'CueCodecState', type: 'Uint' },
            0x5b: { name: 'CueReference', type: 'Container' },
            0x16: { name: 'CueRefTime', type: 'Uint' },
            0x17: { name: 'CueRefCluster', type: 'Uint' },
            0x135f: { name: 'CueRefNumber', type: 'Uint' },
            0x6b: { name: 'CueRefCodecState', type: 'Uint' },
            0x941a469: { name: 'Attachments', type: 'Container' },
            0x21a7: { name: 'AttachedFile', type: 'Container' },
            0x67e: { name: 'FileDescription', type: 'String' },
            0x66e: { name: 'FileName', type: 'String' },
            0x660: { name: 'FileMimeType', type: 'String' },
            0x65c: { name: 'FileData', type: 'Binary' },
            0x6ae: { name: 'FileUID', type: 'Uint' },
            0x675: { name: 'FileReferral', type: 'Binary' },
            0x661: { name: 'FileUsedStartTime', type: 'Uint' },
            0x662: { name: 'FileUsedEndTime', type: 'Uint' },
            0x43a770: { name: 'Chapters', type: 'Container' },
            0x5b9: { name: 'EditionEntry', type: 'Container' },
            0x5bc: { name: 'EditionUID', type: 'Uint' },
            0x5bd: { name: 'EditionFlagHidden', type: 'Uint' },
            0x5db: { name: 'EditionFlagDefault', type: 'Uint' },
            0x5dd: { name: 'EditionFlagOrdered', type: 'Uint' },
            0x36: { name: 'ChapterAtom', type: 'Container' },
            0x33c4: { name: 'ChapterUID', type: 'Uint' },
            0x1654: { name: 'ChapterStringUID', type: 'String' },
            0x11: { name: 'ChapterTimeStart', type: 'Uint' },
            0x12: { name: 'ChapterTimeEnd', type: 'Uint' },
            0x18: { name: 'ChapterFlagHidden', type: 'Uint' },
            0x598: { name: 'ChapterFlagEnabled', type: 'Uint' },
            0x2e67: { name: 'ChapterSegmentUID', type: 'Binary' },
            0x2ebc: { name: 'ChapterSegmentEditionUID', type: 'Uint' },
            0x23c3: { name: 'ChapterPhysicalEquiv', type: 'Uint' },
            0xf: { name: 'ChapterTrack', type: 'Container' },
            0x9: { name: 'ChapterTrackNumber', type: 'Uint' },
            0x0: { name: 'ChapterDisplay', type: 'Container' },
            0x5: { name: 'ChapString', type: 'String' },
            0x37c: { name: 'ChapLanguage', type: 'String' },
            0x37e: { name: 'ChapCountry', type: 'String' },
            0x2944: { name: 'ChapProcess', type: 'Container' },
            0x2955: { name: 'ChapProcessCodecID', type: 'Uint' },
            0x50d: { name: 'ChapProcessPrivate', type: 'Binary' },
            0x2911: { name: 'ChapProcessCommand', type: 'Container' },
            0x2922: { name: 'ChapProcessTime', type: 'Uint' },
            0x2933: { name: 'ChapProcessData', type: 'Binary' },
            0x254c367: { name: 'Tags', type: 'Container' },
            0x3373: { name: 'Tag', type: 'Container' },
            0x23c0: { name: 'Targets', type: 'Container' },
            0x28ca: { name: 'TargetTypeValue', type: 'Uint' },
            0x23ca: { name: 'TargetType', type: 'String' },
            0x23c5: { name: 'TagTrackUID', type: 'Uint' },
            0x23c9: { name: 'TagEditionUID', type: 'Uint' },
            0x23c4: { name: 'TagChapterUID', type: 'Uint' },
            0x23c6: { name: 'TagAttachmentUID', type: 'Uint' },
            0x27c8: { name: 'SimpleTag', type: 'Container' },
            0x5a3: { name: 'TagName', type: 'String' },
            0x47a: { name: 'TagLanguage', type: 'String' },
            0x484: { name: 'TagDefault', type: 'Uint' },
            0x487: { name: 'TagString', type: 'String' },
            0x485: { name: 'TagBinary', type: 'Binary' }
        };
    
        function doInherit(newClass, baseClass) {
            newClass.prototype = Object.create(baseClass.prototype);
            newClass.prototype.constructor = newClass;
        }
    
        function WebmBase(name, type) {
            this.name = name || 'Unknown';
            this.type = type || 'Unknown';
        }
        WebmBase.prototype.updateBySource = function() { };
        WebmBase.prototype.setSource = function(source) {
            this.source = source;
            this.updateBySource();
        };
        WebmBase.prototype.updateByData = function() { };
        WebmBase.prototype.setData = function(data) {
            this.data = data;
            this.updateByData();
        };
    
        function WebmUint(name, type) {
            WebmBase.call(this, name, type || 'Uint');
        }
        doInherit(WebmUint, WebmBase);
        function padHex(hex) {
            return hex.length % 2 === 1 ? '0' + hex : hex;
        }
        WebmUint.prototype.updateBySource = function() {
            // use hex representation of a number instead of number value
            this.data = '';
            for (var i = 0; i < this.source.length; i++) {
                var hex = this.source[i].toString(16);
                this.data += padHex(hex);
            }
        };
        WebmUint.prototype.updateByData = function() {
            var length = this.data.length / 2;
            this.source = new Uint8Array(length);
            for (var i = 0; i < length; i++) {
                var hex = this.data.substr(i * 2, 2);
                this.source[i] = parseInt(hex, 16);
            }
        };
        WebmUint.prototype.getValue = function() {
            return parseInt(this.data, 16);
        };
        WebmUint.prototype.setValue = function(value) {
            this.setData(padHex(value.toString(16)));
        };
    
        function WebmFloat(name, type) {
            WebmBase.call(this, name, type || 'Float');
        }
        doInherit(WebmFloat, WebmBase);
        WebmFloat.prototype.getFloatArrayType = function() {
            return this.source && this.source.length === 4 ? Float32Array : Float64Array;
        };
        WebmFloat.prototype.updateBySource = function() {
            var byteArray = this.source.reverse();
            var floatArrayType = this.getFloatArrayType();
            var floatArray = new floatArrayType(byteArray.buffer);
            this.data = floatArray[0];
        };
        WebmFloat.prototype.updateByData = function() {
            var floatArrayType = this.getFloatArrayType();
            var floatArray = new floatArrayType([ this.data ]);
            var byteArray = new Uint8Array(floatArray.buffer);
            this.source = byteArray.reverse();
        };
        WebmFloat.prototype.getValue = function() {
            return this.data;
        };
        WebmFloat.prototype.setValue = function(value) {
            this.setData(value);
        };
    
        function WebmContainer(name, type) {
            WebmBase.call(this, name, type || 'Container');
        }
        doInherit(WebmContainer, WebmBase);
        WebmContainer.prototype.readByte = function() {
            return this.source[this.offset++];
        };
        WebmContainer.prototype.readUint = function() {
            var firstByte = this.readByte();
            var bytes = 8 - firstByte.toString(2).length;
            var value = firstByte - (1 << (7 - bytes));
            for (var i = 0; i < bytes; i++) {
                // don't use bit operators to support x86
                value *= 256;
                value += this.readByte();
            }
            return value;
        };
        WebmContainer.prototype.updateBySource = function() {
            this.data = [];
            for (this.offset = 0; this.offset < this.source.length; this.offset = end) {
                var id = this.readUint();
                var len = this.readUint();
                var end = Math.min(this.offset + len, this.source.length);
                var data = this.source.slice(this.offset, end);
    
                var info = sections[id] || { name: 'Unknown', type: 'Unknown' };
                var ctr = WebmBase;
                switch (info.type) {
                    case 'Container':
                        ctr = WebmContainer;
                        break;
                    case 'Uint':
                        ctr = WebmUint;
                        break;
                    case 'Float':
                        ctr = WebmFloat;
                        break;
                }
                var section = new ctr(info.name, info.type);
                section.setSource(data);
                this.data.push({
                    id: id,
                    idHex: id.toString(16),
                    data: section
                });
            }
        };
        WebmContainer.prototype.writeUint = function(x, draft) {
            for (var bytes = 1, flag = 0x80; x >= flag && bytes < 8; bytes++, flag *= 0x80) { }
    
            if (!draft) {
                var value = flag + x;
                for (var i = bytes - 1; i >= 0; i--) {
                    // don't use bit operators to support x86
                    var c = value % 256;
                    this.source[this.offset + i] = c;
                    value = (value - c) / 256;
                }
            }
    
            this.offset += bytes;
        };
        WebmContainer.prototype.writeSections = function(draft) {
            this.offset = 0;
            for (var i = 0; i < this.data.length; i++) {
                var section = this.data[i],
                    content = section.data.source,
                    contentLength = content.length;
                this.writeUint(section.id, draft);
                this.writeUint(contentLength, draft);
                if (!draft) {
                    this.source.set(content, this.offset);
                }
                this.offset += contentLength;
            }
            return this.offset;
        };
        WebmContainer.prototype.updateByData = function() {
            // run without accessing this.source to determine total length - need to know it to create Uint8Array
            var length = this.writeSections('draft');
            this.source = new Uint8Array(length);
            // now really write data
            this.writeSections();
        };
        WebmContainer.prototype.getSectionById = function(id) {
            for (var i = 0; i < this.data.length; i++) {
                var section = this.data[i];
                if (section.id === id) {
                    return section.data;
                }
            }
            return null;
        };
    
        function WebmFile(source) {
            WebmContainer.call(this, 'File', 'File');
            this.setSource(source);
        }
        doInherit(WebmFile, WebmContainer);
        WebmFile.prototype.fixDuration = function(duration, options) {
            var logger = options && options.logger;
            if (logger === undefined) {
                logger = function(message) {
                    console.log(message);
                };
            } else if (!logger) {
                logger = function() { };
            }
    
            var segmentSection = this.getSectionById(0x8538067);
            if (!segmentSection) {
                logger('[fix-webm-duration] Segment section is missing');
                return false;
            }
    
            var infoSection = segmentSection.getSectionById(0x549a966);
            if (!infoSection) {
                logger('[fix-webm-duration] Info section is missing');
                return false;
            }
    
            var timeScaleSection = infoSection.getSectionById(0xad7b1);
            if (!timeScaleSection) {
                logger('[fix-webm-duration] TimecodeScale section is missing');
                return false;
            }
    
            var durationSection = infoSection.getSectionById(0x489);
            if (durationSection) {
                if (durationSection.getValue() <= 0) {
                    logger(`[fix-webm-duration] Duration section is present, but the value is ${durationSection.getValue()}`);
                    durationSection.setValue(duration);
                } else {
                    logger(`[fix-webm-duration] Duration section is present, and the value is ${durationSection.getValue()}`);
                    return false;
                }
            } else {
                logger('[fix-webm-duration] Duration section is missing');
                // append Duration section
                durationSection = new WebmFloat('Duration', 'Float');
                durationSection.setValue(duration);
                infoSection.data.push({
                    id: 0x489,
                    data: durationSection
                });
            }
    
            // set default time scale to 1 millisecond (1000000 nanoseconds)
            timeScaleSection.setValue(1000000);
            infoSection.updateByData();
            segmentSection.updateByData();
            this.updateByData();
    
            return true;
        };
        WebmFile.prototype.toBlob = function(mimeType) {
            return new Blob([ this.source.buffer ], { type: mimeType || 'video/webm' });
        };
    
        function fixWebmDuration(blob, duration, callback, options) {
            // The callback may be omitted - then the third argument is options
            if (typeof callback === "object") {
                options = callback;
                callback = undefined;
            }
    
            if (!callback) {
                return new Promise(function(resolve) {
                    fixWebmDuration(blob, duration, resolve, options);
                });
            }
    
            try {
                var reader = new FileReader();
                reader.onloadend = function() {
                    try {
                        var file = new WebmFile(new Uint8Array(reader.result));
                        if (file.fixDuration(duration, options)) {
                            blob = file.toBlob(blob.type);
                        }
                    } catch (ex) {
                        // ignore
                    }
                    callback(blob);
                };
                reader.readAsArrayBuffer(blob);
            } catch (ex) {
                callback(blob);
            }
        }
    
        // Support AMD import default
        fixWebmDuration.default = fixWebmDuration;
    
        return fixWebmDuration;
    });
    </script>
</head>
<body>
    <h1>Screen Recorder</h1>
    
    <div class="container">
         <div class="loading">
            <div class="spinner"></div>
            <p>Preparing recording. Please wait...</p>
        </div>
        <div class="recording-column">
            <div id="timer">00:00:00</div>
            <div class="recording-indicator">● Recording</div>
            <div id="fileSize" class="file-size">File size: 0 MB</div>

            <div class="screen-select">
                <h2>Select what to record:</h2>
                <div class="controls">
                    <button class="screen-option" data-type="screen" title="Record Entire Screen">
                        <div>Monitor Screen</div>
                        <small>Record your entire monitor display</small>
                    </button>
                    <button class="screen-option" data-type="window" title="Record Application Window">
                        <div>Application Window</div>
                        <small>Record a specific window</small>
                    </button>
                    <button class="screen-option" data-type="tab" title="Record Browser Tab">
                        <div>Browser Tab</div>
                        <small>Record current browser tab</small>
                    </button>
                </div>
            </div>

            <div class="controls">
                <button id="startCapture" title="Start Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                        <circle cx="12" cy="12" r="8" fill="currentColor"/>
                    </svg>
                </button>
                <button id="stopCapture" disabled title="Stop Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="currentColor" stroke="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-square"><rect x="3" y="3" width="18" height="18" rx="4" ry="4"></rect></svg>
                </button>
                <button id="toggleVideo" title="Hide Recording">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hide-icon">
                        <polygon points="23 7 16 12 23 17 23 7"></polygon>
                        <rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect>
                    </svg>
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="show-icon">
                        <path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path>
                        <line x1="1" y1="1" x2="23" y2="23"></line>
                    </svg>
                </button>
            </div>

            <div class="settings">
                <select id="qualitySelect">
                    <option value="ultra">Ultra Quality</option>
                    <option value="high">High Quality</option>
                    <option value="medium">Medium Quality</option>
                    <option value="low">Low Quality</option>
                    <option value="lowest">Lowest Quality</option>
                </select>
                <select id="formatSelect">
                    <option value="webm">WebM</option>
                    <option value="mp4">MP4</option>
                </select>
               
            </div>

            <video id="screenVideo" autoplay playsinline muted controlsList="nodownload"></video>
        </div>

        <div class="playback-column">
            <div id="videoContainer" class="video-container">
                <div class="video-title"></div>
                <video id="playbackVideo" controlsList="nodownload"></video>
                <button class="close-video-btn" title="Close Video">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                        <path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" fill="white"/>
                    </svg>
                </button>
            </div>
            <div class="video-controls">
                <button id="playPauseBtn">
                    <svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
                </button>
                <input type="range" id="seekBar" value="0">
                <span id="currentTime">0:00</span> / <span id="duration">0:00</span>
            </div>
            
            <div class="recording-history">
                <div class="history-top">
                    <div class="history-header">
                        <h2>Recording History</h2>
                    </div>
                    <div class="storage-info">
                        <div class="storage-text">Storage Used: <span id="storageUsed">0 MB</span></div>
                        <div class="storage-bar">
                            <div class="storage-fill"></div>
                        </div>
                    </div>
                    <button id="deleteAllBtn" class="delete-all-btn">
                        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="3 6 5 6 21 6"></polyline>
                            <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
                        </svg>
                        Delete All
                    </button>
                </div>
                <div id="historyList" class="history-list">
                    <!-- History items will be added here dynamically -->
                </div>
            </div>
        </div>
    </div>

    <div class="overlay"></div>
    <div class="save-dialog">
        <h3>Save Recording</h3>
        <div class="filename-container">
            <input type="text" id="filename" placeholder="Enter filename">
            <span class="extension"></span>
        </div>
        <div class="buttons">
            <button id="cancelSave" title="Cancel Saving">Cancel</button>
            <button id="confirmSave" title="Confirm Save">Save</button>
        </div>
    </div>

    <script>
        const startButton = document.getElementById("startCapture");
        const stopButton = document.getElementById("stopCapture");
        const video = document.getElementById("screenVideo");
        const timerElement = document.getElementById("timer");
        const recordingIndicator = document.querySelector(".recording-indicator");
        const screenSelect = document.querySelector(".screen-select");
        const loading = document.querySelector(".loading");
        const fileSizeElement = document.getElementById('fileSize');
        const toggleVideoButton = document.getElementById("toggleVideo");
        let isVideoVisible = true;

        let captureStream = null;
        let mediaRecorder = null;
        let recordedChunks = [];
        let startTime = 0;
        let timerInterval = null;

        const qualitySelect = document.getElementById("qualitySelect");
        const formatSelect = document.getElementById("formatSelect");

        let recordingHistory = [];
        let db;

        let recordingDuration = 0;
        let finalRecordingDuration = 0;

        async function requestMaxStorageQuota() {
            try {
                if ('storage' in navigator && 'persist' in navigator) {
                    // Request persistent storage permission
                    await navigator.storage.persist();
                    
                    // Get available storage space
                    const estimate = await navigator.storage.estimate();
                    console.log(`Available storage: ${estimate.quota} bytes`);
                    console.log(`Used storage: ${estimate.usage} bytes`);
                    
                    return estimate.quota;
                }
                // Fallback to a high value if Storage API is not available
                return 1024 * 1024 * 1024 // 10GB default
            } catch (error) {
                console.warn('Error requesting storage quota:', error);
                return 1024 * 1024 * 1024; // 10GB fallback
            }
        }

        function saveSettings() {
            const settings = {
                quality: qualitySelect.value,
                format: formatSelect.value,
                isVideoVisible: isVideoVisible
            };
            localStorage.setItem('screenRecorderSettings', JSON.stringify(settings));
        }

        function loadSettings() {
            const savedSettings = localStorage.getItem('screenRecorderSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                
                // Check if Safari and force MP4
                const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
                if (isSafari) {
                    formatSelect.value = 'mp4';
                    formatSelect.disabled = true;
                } else {
                    formatSelect.value = settings.format || 'webm';
                    formatSelect.disabled = false;
                }
                
                qualitySelect.value = settings.quality || 'high';
                isVideoVisible = settings.isVideoVisible ?? true;
                
                // Update toggle button state
                const showIcon = toggleVideoButton.querySelector('.show-icon');
                const hideIcon = toggleVideoButton.querySelector('.hide-icon');
                
                if (isVideoVisible) {
                    showIcon.classList.remove('active');
                    hideIcon.classList.add('active');
                    toggleVideoButton.classList.remove('showing');
                    toggleVideoButton.title = 'Hide Recording';
                } else {
                    showIcon.classList.add('active');
                    hideIcon.classList.remove('active');
                    toggleVideoButton.classList.add('showing');
                    toggleVideoButton.title = 'Show Recording';
                }
            } else {
                // Set default state
                const showIcon = toggleVideoButton.querySelector('.show-icon');
                const hideIcon = toggleVideoButton.querySelector('.hide-icon');
                hideIcon.classList.add('active');
                showIcon.classList.remove('active');
                toggleVideoButton.classList.remove('showing');
                toggleVideoButton.title = 'Hide Recording';
            }
        }

        function getRecordingOptions(format, quality) {
            const options = {
                webm: {
                    ultra: { videoBitsPerSecond: 12000000 },    // 12 Mbps
                    high: { videoBitsPerSecond: 8000000 },      // 8 Mbps
                    medium: { videoBitsPerSecond: 4000000 },    // 4 Mbps
                    low: { videoBitsPerSecond: 2000000 },       // 2 Mbps
                    lowest: { videoBitsPerSecond: 1000000 }     // 1 Mbps
                },
                mp4: {
                    ultra: { videoBitsPerSecond: 20000000 },    // 20 Mbps
                    high: { videoBitsPerSecond: 12000000 },     // 12 Mbps
                    medium: { videoBitsPerSecond: 8000000 },    // 8 Mbps
                    low: { videoBitsPerSecond: 4000000 },       // 4 Mbps
                    lowest: { videoBitsPerSecond: 2000000 }     // 2 Mbps
                }
            };
            
            return options[format][quality];
        }

        // Update the quality select options HTML
        qualitySelect.innerHTML = `
            <option value="ultra">Ultra Quality</option>
            <option value="high">High Quality</option>
            <option value="medium">Medium Quality</option>
            <option value="low">Low Quality</option>
            <option value="lowest">Lowest Quality</option>
        `;

        // Add these event listeners after the formatSelect definition (around line 880)
        qualitySelect.addEventListener('change', () => {
            saveSettings();
            updateQualityDescriptions();
        });

        formatSelect.addEventListener('change', () => {
            saveSettings();
            updateQualityDescriptions();
        });

        function updateQualityDescriptions() {
            const format = formatSelect.value;
            const qualityDescriptions = {
                webm: {
                    ultra: "Ultra Quality (12 Mbps)",
                    high: "High Quality (8 Mbps)",
                    medium: "Medium Quality (4 Mbps)",
                    low: "Low Quality (2 Mbps)",
                    lowest: "Lowest Quality (1 Mbps)"
                },
                mp4: {
                    ultra: "Ultra Quality (20 Mbps)",
                    high: "High Quality (12 Mbps)",
                    medium: "Medium Quality (8 Mbps)",
                    low: "Low Quality (4 Mbps)",
                    lowest: "Lowest Quality (2 Mbps)"
                }
            };

            const options = qualitySelect.options;
            for (let i = 0; i < options.length; i++) {
                const quality = options[i].value;
                options[i].textContent = qualityDescriptions[format][quality];
            }
        }

        // Call this initially to set the correct descriptions
        updateQualityDescriptions();

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && e.target === document.body) {
                e.preventDefault();
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    pauseRecording();
                }
            } else if (e.code === 'KeyR' && e.ctrlKey) {
                e.preventDefault();
                if (!mediaRecorder) {
                    startButton.click();
                }
            } else if (e.code === 'KeyS' && e.ctrlKey) {
                e.preventDefault();
                if (mediaRecorder && mediaRecorder.state === 'recording') {
                    stopRecording();
                }
            }
        });

        function updateTimer() {
            const elapsed = Date.now() - startTime;
            const seconds = Math.floor((elapsed / 1000) % 60);
            const minutes = Math.floor((elapsed / (1000 * 60)) % 60);
            const hours = Math.floor(elapsed / (1000 * 60 * 60));
            
            recordingDuration = elapsed / 1000;
            finalRecordingDuration = recordingDuration;
            console.log('Current recording duration:', recordingDuration);
            timerElement.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        async function checkScreenCapturePermissions() {
            // Check if running on macOS
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            
            if (isMac) {
                try {
                    // Check system permissions
                    const permissionStatus = await navigator.permissions.query({ name: 'screen-capture' }).catch(() => ({ state: 'not-supported' }));
                    
                    if (permissionStatus.state === 'denied') {
                        throw new Error(
                            'Screen recording permission is denied. Please follow these steps:\n\n' +
                            '1. Open System Preferences\n' +
                            '2. Go to Security & Privacy > Privacy > Screen Recording\n' +
                            '3. Enable permission for your browser\n' +
                            '4. Restart your browser'
                        );
                    }
                } catch (err) {
                    if (err.message.includes('Screen recording permission')) {
                        throw err;
                    }
                    // If permission query isn't supported, we'll try direct capture
                }
            }
        }

        async function startRecording(displayMediaOptions) {
            try {
                loading.classList.add('visible');
                
                // Hide the screen select options when starting recording
                screenSelect.classList.remove('visible');
                
                // Hide playback video if it's visible
                const playbackVideo = document.getElementById('playbackVideo');
                const videoContainer = document.getElementById('videoContainer');
                playbackVideo.src = ''; // Clear the source
                playbackVideo.style.display = "none"; // Hide the video element
                videoContainer.classList.remove('active');
                document.querySelector('.video-controls').classList.remove('active');
                
                // Add Mac-specific checks and options
                await checkScreenCapturePermissions();
                
                // Modify displayMediaOptions for better Mac compatibility
                const macDisplayMediaOptions = {
                    ...displayMediaOptions,
                    video: {
                        ...displayMediaOptions.video,
                        frameRate: 30,
                        displaySurface: displayMediaOptions.video.displaySurface || 'monitor',
                        logicalSurface: true,
                        cursor: 'always',
                        suppressLocalAudioPlayback: true,
                    },
                    preferCurrentTab: false,
                    selfBrowserSurface: 'include',
                    systemAudio: 'include',
                };

                try {
                    captureStream = await navigator.mediaDevices.getDisplayMedia(macDisplayMediaOptions);
                } catch (err) {
                    if (err.name === 'NotReadableError') {
                        throw new Error(
                            'Unable to access the screen. Please try these steps:\n\n' +
                            '1. Check System Preferences > Security & Privacy > Privacy > Screen Recording\n' +
                            '2. Ensure your browser has screen recording permission\n' +
                            '3. Quit and restart your browser\n' +
                            '4. If using multiple displays, try selecting a different display\n' +
                            '5. Try closing other applications that might be using screen capture'
                        );
                    } else if (err.name === 'NotAllowedError') {
                        throw new Error(
                            'Permission denied. Please:\n\n' +
                            '1. Allow screen recording permission in the browser prompt\n' +
                            '2. Check System Preferences > Security & Privacy > Privacy > Screen Recording\n' +
                            '3. Restart your browser after enabling permissions'
                        );
                    } else {
                        throw new Error(`Screen capture error: ${err.message}\n\nPlease ensure screen recording permissions are enabled in System Preferences.`);
                    }
                }

                // Check if we actually got a valid stream
                if (!captureStream || !captureStream.active) {
                    throw new Error('Failed to get a valid screen capture stream.');
                }

                video.srcObject = captureStream;
                video.style.display = isVideoVisible ? "block" : "none";
                video.classList.add('active');
                video.classList.add('recording');
                
                const quality = qualitySelect.value;
                const format = formatSelect.value;
                const mimeType = format === 'mp4' ? 'video/mp4' : 'video/webm;codecs=vp9';
                
                // Check if the selected format is supported
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    throw new Error(`${format.toUpperCase()} format is not supported by your browser. Please try a different format.`);
                }

                const recordingOptions = getRecordingOptions(format, quality);

                try {
                    mediaRecorder = new MediaRecorder(captureStream, {
                        mimeType: mimeType,
                        ...recordingOptions
                    });
                } catch (err) {
                    throw new Error(`Failed to initialize recorder: ${err.message}`);
                }
                
                recordedChunks = [];
                fileSizeElement.textContent = 'File size: 0 MB';

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                        const actualSize = recordedChunks.reduce((total, chunk) => total + chunk.size, 0) / (1024 * 1024);
                        fileSizeElement.textContent = `File size: ${actualSize.toFixed(1)} MB`;
                    }
                };

                // Add error handler for mediaRecorder
                mediaRecorder.onerror = (event) => {
                    console.error('MediaRecorder error:', event.error);
                    stopRecording();
                    alert(`Recording error: ${event.error.message || 'Unknown error occurred'}`);
                };

                mediaRecorder.onstop = async () => {
                    const format = formatSelect.value;
                    let blob;
                    
                    if (format === 'webm') {
                        // Apply duration fix only for WebM format
                        try {
                            const rawBlob = new Blob(recordedChunks, { type: 'video/webm' });
                            blob = await window.ysFixWebmDuration(rawBlob, finalRecordingDuration * 1000, {
                                logger: false  // Set to true for debugging
                            });
                        } catch (error) {
                            console.warn('WebM duration fix failed:', error);
                            // Fallback to original blob if fix fails
                            blob = new Blob(recordedChunks, { type: 'video/webm' });
                        }
                    } else {
                        // For MP4 format, use original blob
                        blob = new Blob(recordedChunks, { type: 'video/mp4' });
                    }
                    
                    const saveDialog = document.querySelector('.save-dialog');
                    const overlay = document.querySelector('.overlay');
                    const filenameInput = document.getElementById('filename');
                    const extensionSpan = document.querySelector('.extension');
                    
                    // Set the extension text
                    extensionSpan.textContent = format === 'mp4' ? '.mp4' : '.webm';
                    
                    // Get recording type for filename
                    const recordingType = displayMediaOptions.video.displaySurface || 'tab';
                    const recordingTypeNames = {
                        'monitor': 'Screen',
                        'window': 'Window',
                        'browser': 'Tab',
                        'tab': 'Tab'
                    };
                    
                    // Get date and time components
                    const now = new Date();
                    const date = now.toISOString().split('T')[0].replace(/-/g, ''); // YYYYMMDD
                    const time = now.toTimeString().split(' ')[0].replace(/:/g, ''); // HHMMSS
                    
                    // Calculate duration in seconds
                    const durationSecs = Math.round(finalRecordingDuration);
                    const durationStr = durationSecs < 60 ? `${durationSecs}s` : `${Math.round(durationSecs/60)}m`;
                    
                    // Construct filename
                    const defaultFilename = `Recording_${recordingTypeNames[recordingType]}_${date}_${time}_${durationStr}`;
                    
                    filenameInput.value = defaultFilename;
                    saveDialog.classList.add('active');
                    overlay.classList.add('active');
                    
                    const handleSave = () => {
                        let filename = filenameInput.value.trim();
                        if (filename) {
                            const extension = format === 'mp4' ? '.mp4' : '.webm';
                            if (!filename.toLowerCase().endsWith(extension)) {
                                filename += extension;
                            }
                            
                            const actualSize = blob.size / (1024 * 1024);
                            
                            // Save to IndexedDB
                            const transaction = db.transaction(['recordings'], 'readwrite');
                            const store = transaction.objectStore('recordings');
                            
                            const recordingType = displayMediaOptions.video.displaySurface || 'tab';
                            
                            store.add({
                                filename: filename,
                                blob: blob,
                                timestamp: new Date().toISOString(),
                                size: actualSize.toFixed(1),
                                type: format === 'mp4' ? 'video/mp4' : 'video/webm',
                                recordingType: recordingType,
                                duration: finalRecordingDuration
                            });
                            console.log('Duration saved to DB:', finalRecordingDuration);

                            transaction.oncomplete = () => {
                                loadRecordingHistory();
                                
                                // Remove the automatic download code
                            };
                        }
                        
                        cleanup();
                    };

                    const cleanup = () => {
                        saveDialog.classList.remove('active');
                        overlay.classList.remove('active');
                        
                        // Remove event listeners
                        document.getElementById('confirmSave').removeEventListener('click', handleSave);
                        document.getElementById('cancelSave').removeEventListener('click', cleanup);
                        filenameInput.removeEventListener('keyup', handleEnterKey);
                    };

                    const handleEnterKey = (e) => {
                        if (e.key === 'Enter') {
                            handleSave();
                        }
                    };

                    // Add event listeners
                    document.getElementById('confirmSave').addEventListener('click', handleSave);
                    document.getElementById('cancelSave').addEventListener('click', cleanup);
                    filenameInput.addEventListener('keyup', handleEnterKey);
                };

                mediaRecorder.start(1000);
                startTime = Date.now();
                timerInterval = setInterval(updateTimer, 1000);
                
                startButton.disabled = true;
                stopButton.disabled = false;
                startButton.classList.add('recording');
                startButton.innerHTML = `
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                        <circle cx="12" cy="12" r="8" fill="currentColor"/>
                    </svg>
                `;
                recordingIndicator.classList.add('active');
                screenSelect.classList.remove('visible');
                loading.classList.remove('visible');

                // Add stream stop handler
                captureStream.getVideoTracks()[0].onended = () => {
                    console.log('Screen sharing stopped by user');
                    stopRecording();
                };

            } catch (err) {
                console.error("Error starting screen recording:", err);
                loading.classList.remove('visible');
                screenSelect.classList.remove('visible');
                
                // Show a user-friendly error message
                alert(err.message || "Failed to start recording. Please try again.");
                
                // Reset UI state
                startButton.disabled = false;
                stopButton.disabled = true;
                startButton.classList.remove('recording');
                
                // Cleanup any partial setup
                if (captureStream) {
                    captureStream.getTracks().forEach(track => track.stop());
                    captureStream = null;
                }
                if (video.srcObject) {
                    video.srcObject = null;
                }
                video.style.display = "none";
                video.classList.remove('active');
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                finalRecordingDuration = recordingDuration;
                console.log('Storing final duration before stop:', finalRecordingDuration);
                mediaRecorder.stop();
            }

            if (captureStream) {
                captureStream.getTracks().forEach(track => track.stop());
                captureStream = null;
                video.srcObject = null;
                video.style.display = "none";
                video.classList.remove('active', 'recording');
            }
            
            clearInterval(timerInterval);
            timerElement.textContent = "00:00:00";
            startButton.disabled = false;
            stopButton.disabled = true;
            startButton.classList.remove('recording');
            startButton.innerHTML = `
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16">
                    <circle cx="12" cy="12" r="8" fill="currentColor"/>
                </svg>
            `;
            recordingIndicator.classList.remove('active');
            
            recordingDuration = 0;
        }

        startButton.addEventListener("click", () => {
            // Hide any playing video and reset controls
            video.src = '';
            video.style.display = "none";
            video.classList.remove('active');
            document.querySelector('.video-controls').classList.remove('active');
            
            // Show the screen select options
            screenSelect.classList.add('visible');
        });

        document.querySelectorAll('.screen-option').forEach(button => {
            button.addEventListener('click', () => {
                const type = button.dataset.type;
                const displayMediaOptions = {
                    video: {
                        cursor: "always",
                        ...(type === 'screen' && {
                            displaySurface: "monitor",
                            logicalSurface: true
                        }),
                        ...(type === 'window' && {
                            displaySurface: "window"
                        }),
                        ...(type === 'tab' && {
                            displaySurface: "browser",
                            browserWindow: true
                        })
                    },
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        sampleRate: 44100
                    },
                    selfBrowserSurface: "include",
                    systemAudio: "include"
                };
                startRecording(displayMediaOptions);
            });
        });

        stopButton.addEventListener("click", stopRecording);

        toggleVideoButton.addEventListener("click", () => {
            isVideoVisible = !isVideoVisible;
            if (video.srcObject) {
                video.style.display = isVideoVisible ? "block" : "none";
            }
            
            const showIcon = toggleVideoButton.querySelector('.show-icon');
            const hideIcon = toggleVideoButton.querySelector('.hide-icon');
            
            if (isVideoVisible) {
                showIcon.classList.remove('active');
                hideIcon.classList.add('active');
                toggleVideoButton.classList.remove('showing');
                toggleVideoButton.title = 'Hide Recording';
            } else {
                showIcon.classList.add('active');
                hideIcon.classList.remove('active');
                toggleVideoButton.classList.add('showing');
                toggleVideoButton.title = 'Show Recording';
            }
            
            saveSettings();
        });

        document.addEventListener('DOMContentLoaded', () => {
            loadSettings();
            initDB();
            updateQualityDescriptions();

            // Add delete all button event listener after DOM is loaded
            document.addEventListener('click', (e) => {
                if (e.target.closest('#deleteAllBtn')) {
                    if (recordingHistory.length === 0) {
                        alert('No recordings to delete.');
                        return;
                    }

                    if (confirm('Are you sure you want to delete all recordings? This action cannot be undone.')) {
                        const transaction = db.transaction(['recordings'], 'readwrite');
                        const store = transaction.objectStore('recordings');
                        const request = store.clear();

                        request.onsuccess = () => {
                            recordingHistory = [];
                            updateHistoryDisplay();
                            updateStorageInfo();
                        };

                        request.onerror = () => {
                            alert('Error deleting recordings.');
                        };
                    }
                }
            });
        });

        function loadRecordingHistory() {
            if (!db) return;

            const transaction = db.transaction(['recordings'], 'readonly');
            const store = transaction.objectStore('recordings');
            const request = store.getAll();

            request.onsuccess = () => {
                recordingHistory = request.result;
                updateHistoryDisplay();
                updateStorageInfo();
            };
        }

        function updateHistoryDisplay() {
            const historyList = document.getElementById('historyList');
            const currentHeight = historyList.scrollHeight;
            
            // Sort recordings by timestamp in descending order (newest first)
            recordingHistory.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            // Update delete all button visibility
            const deleteAllBtn = document.getElementById('deleteAllBtn');
            if (deleteAllBtn) {
                deleteAllBtn.classList.toggle('visible', recordingHistory.length > 0);
            }
            
            // Clear the history list
            historyList.innerHTML = '';
            
            historyList.style.height = currentHeight + 'px';

            recordingHistory.forEach((recording) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item';
                historyItem.setAttribute('data-id', recording.id); // Add this line
                
                const date = new Date(recording.timestamp);
                const formattedDate = date.toLocaleString();
                
                const recordingTypeDisplay = {
                    'monitor': 'Full Screen',
                    'window': 'Application Window',
                    'browser': 'Browser Tab',
                    'tab': 'Browser Tab'
                }[recording.recordingType] || 'Screen Recording';
                
                // Get the appropriate icon based on recording type
                const recordingTypeIcon = {
                    'monitor': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>',
                    'window': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>',
                    'browser': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>',
                    'tab': '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>'
                }[recording.recordingType] || '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>';
                
                historyItem.innerHTML = `
                    <div class="history-item-info">
                        <div class="history-item-filename">${recording.filename}</div>
                        <div class="history-item-details">
                            <span>
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>
                                ${formattedDate}
                            </span>
                            <span>
                                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                                ${recording.size} MB
                            </span>
                            <span>
                                ${recordingTypeIcon}
                                ${recordingTypeDisplay}
                            </span>
                        </div>
                    </div>
                    <div class="history-item-actions">
                        <button class="play-btn" onclick="playRecording(${recording.id})" title="Play Recording">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
                        </button>
                        <button class="download-btn" onclick="downloadRecording(${recording.id})" title="Download Recording">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                                <polyline points="7 10 12 15 17 10"></polyline>
                                <line x1="12" y1="15" x2="12" y2="3"></line>
                            </svg>
                        </button>
                        <button class="delete-btn" onclick="deleteRecording(${recording.id})" title="Delete Recording">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                    </div>
                `;
                
                historyList.appendChild(historyItem);
            });

            requestAnimationFrame(() => {
                historyList.style.height = historyList.scrollHeight + 'px';
            });
        }

        function playRecording(id) {
            // First remove 'playing' class from all history items
            document.querySelectorAll('.history-item').forEach(item => {
                item.classList.remove('playing');
            });

            const transaction = db.transaction(['recordings'], 'readonly');
            const store = transaction.objectStore('recordings');
            const request = store.get(id);

            request.onsuccess = () => {
                const recording = request.result;
                if (recording) {
                    const url = URL.createObjectURL(recording.blob);
                    const playbackVideo = document.getElementById('playbackVideo');
                    const videoContainer = document.getElementById('videoContainer');
                    const videoTitle = document.querySelector('.video-title');
                    
                    // Set and show the video title
                    videoTitle.textContent = recording.filename;
                    videoTitle.classList.add('active');
                    
                    // Find and highlight the current playing item in the list
                    const historyItem = document.querySelector(`.history-item[data-id="${id}"]`);
                    if (historyItem) {
                        historyItem.classList.add('playing');
                        // Scroll the playing item into view if needed
                        historyItem.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }

                    playbackVideo.src = url;
                    playbackVideo.style.display = "block";
                    videoContainer.classList.add('active');
                    
                    // Store the duration as a data attribute
                    playbackVideo.dataset.storedDuration = recording.duration;
                    console.log('Set video duration attribute:', playbackVideo.dataset.storedDuration);
                    
                    // Make sure video controls are visible
                    const videoControls = document.querySelector('.video-controls');
                    videoControls.classList.add('active');
                    
                    setupVideoControls();
                    
                    // Initialize play button state and start playing
                    updatePlayPauseButton(true);
                    
                    // Scroll the playback video into view smoothly
                    playbackVideo.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Autoplay the video
                    playbackVideo.play();
                    
                    playbackVideo.onloadedmetadata = () => {
                        console.log('Video loadedmetadata - duration:', playbackVideo.duration);
                        console.log('Stored duration on load:', playbackVideo.dataset.storedDuration);
                    };
                    
                    playbackVideo.onended = () => {
                        URL.revokeObjectURL(url);
                    };
                }
            };
        }

        function deleteRecording(id) {
            if (confirm('Are you sure you want to delete this recording?')) {
                const transaction = db.transaction(['recordings'], 'readwrite');
                const store = transaction.objectStore('recordings');
                store.delete(id);
                
                transaction.oncomplete = () => {
                    loadRecordingHistory();
                    updateStorageInfo();
                };
            }
        }

        function setupVideoControls() {
            const playbackVideo = document.getElementById('playbackVideo');
            const playPauseBtn = document.getElementById('playPauseBtn');
            const seekBar = document.getElementById('seekBar');
            const currentTime = document.getElementById('currentTime');
            const duration = document.getElementById('duration');
            const videoControls = document.querySelector('.video-controls');

            // Remove existing event listeners
            playPauseBtn.replaceWith(playPauseBtn.cloneNode(true));
            seekBar.replaceWith(seekBar.cloneNode(true));
            
            // Get the new elements after replacement
            const newPlayPauseBtn = document.getElementById('playPauseBtn');
            const newSeekBar = document.getElementById('seekBar');

            // Add this new click handler for the play/pause button
            newPlayPauseBtn.addEventListener('click', () => {
                if (playbackVideo.paused) {
                    playbackVideo.play();
                } else {
                    playbackVideo.pause();
                }
            });

            // Reset controls state
            videoControls.classList.add('active');
            newSeekBar.value = 0;
            currentTime.textContent = '0:00';
            duration.textContent = '0:00';

            playbackVideo.addEventListener('loadedmetadata', () => {
                console.log('Video loadedmetadata - duration:', playbackVideo.duration);
                console.log('Stored duration on load:', playbackVideo.dataset.storedDuration);
                
                if (!isFinite(playbackVideo.duration) && playbackVideo.dataset.storedDuration) {
                    newSeekBar.max = Math.floor(playbackVideo.dataset.storedDuration);
                    duration.textContent = formatTime(playbackVideo.dataset.storedDuration);
                    console.log('Using stored duration:', playbackVideo.dataset.storedDuration);
                } else if (isFinite(playbackVideo.duration)) {
                    newSeekBar.max = Math.floor(playbackVideo.duration);
                    duration.textContent = formatTime(playbackVideo.duration);
                    console.log('Using video duration:', playbackVideo.duration);
                }
            });

            // Update time display and seek bar position
            playbackVideo.addEventListener('timeupdate', () => {
                if (!newSeekBar.dragging) {
                    newSeekBar.value = Math.floor(playbackVideo.currentTime);
                    currentTime.textContent = formatTime(playbackVideo.currentTime);
                }
            });

            newSeekBar.addEventListener('input', () => {
                currentTime.textContent = formatTime(newSeekBar.value);
            });

            newSeekBar.addEventListener('mousedown', () => {
                newSeekBar.dragging = true;
            });

            newSeekBar.addEventListener('mouseup', () => {
                newSeekBar.dragging = false;
            });

            newSeekBar.addEventListener('change', () => {
                playbackVideo.currentTime = newSeekBar.value;
                newSeekBar.dragging = false;
            });

            playbackVideo.addEventListener('play', () => {
                updatePlayPauseButton(true);
            });

            playbackVideo.addEventListener('pause', () => {
                updatePlayPauseButton(false);
            });

            // Initial state
            updatePlayPauseButton(false);
        }

        function formatTime(seconds) {
            if (!isFinite(seconds)) return '0:00';
            const minutes = Math.floor(seconds / 60);
            seconds = Math.floor(seconds % 60);
            return `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function updatePlayPauseButton(isPlaying) {
            const playPauseBtn = document.getElementById('playPauseBtn');
            playPauseBtn.innerHTML = isPlaying ? 
                '<svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>' : 
                '<svg viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>';
            
            if (isPlaying) {
                playPauseBtn.classList.add('playing');
            } else {
                playPauseBtn.classList.remove('playing');
            }
        }

        const historyHeader = document.querySelector('.history-header');
        const historyList = document.getElementById('historyList');
        
        historyHeader.addEventListener('click', (e) => {
            if (e.target.closest('.delete-all-btn')) return;
            
            historyHeader.classList.toggle('collapsed');
            historyList.classList.toggle('collapsed');
            
            // Also toggle the delete all button visibility based on collapsed state
            const deleteAllBtn = document.getElementById('deleteAllBtn');
            if (deleteAllBtn) {
                if (historyHeader.classList.contains('collapsed')) {
                    deleteAllBtn.style.opacity = '0';
                    deleteAllBtn.style.pointerEvents = 'none';
                } else {
                    deleteAllBtn.style.opacity = '1';
                    deleteAllBtn.style.pointerEvents = 'auto';
                }
            }
            
            if (!historyList.classList.contains('collapsed')) {
                historyList.style.height = historyList.scrollHeight + 'px';
            }
        });

        async function updateStorageInfo() {
            const transaction = db.transaction(['recordings'], 'readonly');
            const store = transaction.objectStore('recordings');
            const request = store.getAll();

            request.onsuccess = async () => {
                const recordings = request.result;
                let totalSize = 0;
                
                recordings.forEach(recording => {
                    totalSize += recording.blob.size;
                });

                const totalMB = (totalSize / (1024 * 1024)).toFixed(1);
                const storageUsedElement = document.getElementById('storageUsed');
                const storageFill = document.querySelector('.storage-fill');
                
                // Get maximum available quota
                const quotaInBytes = await requestMaxStorageQuota();
                const quotaInMB = quotaInBytes / (1024 * 1024);
                
                // Update to show used/total format with appropriate units
                let usedDisplay;
                if (totalMB > 1024) {
                    usedDisplay = `${(totalMB / 1024).toFixed(1)} GB`;
                } else {
                    usedDisplay = `${totalMB} MB`;
                }
                
                storageUsedElement.textContent = usedDisplay;
                
                // Calculate percentage used
                const percentageUsed = Math.min((totalSize / quotaInBytes) * 100, 100);
                storageFill.style.width = `${percentageUsed}%`;
                
                // Change color based on usage
                if (percentageUsed > 90) {
                    storageFill.style.backgroundColor = '#dc3545';
                } else if (percentageUsed > 70) {
                    storageFill.style.backgroundColor = '#ffc107';
                } else {
                    storageFill.style.backgroundColor = 'var(--accent-color)';
                }
            };
        }

        const initDB = () => {
            requestMaxStorageQuota().then(() => {
                const request = indexedDB.open('ScreenRecorderDB', 1);
                
                request.onerror = (event) => {
                    console.error('IndexedDB error:', event.target.error);
                };

                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('recordings')) {
                        db.createObjectStore('recordings', { keyPath: 'id', autoIncrement: true });
                    }
                };

                request.onsuccess = (event) => {
                    db = event.target.result;
                    loadRecordingHistory();
                };
            });
        };

        function checkBrowserCompatibility() {
            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const browser = {
                chrome: !!window.chrome && navigator.vendor === "Google Inc.",
                firefox: typeof InstallTrigger !== 'undefined',
                safari: /^((?!chrome|android).)*safari/i.test(navigator.userAgent)
            };

            if (browser.safari) {
                // Force MP4 format for Safari
                formatSelect.value = 'mp4';
                formatSelect.disabled = true;
                
                if (isMac) {
                    alert('Safari has limited screen recording capabilities. For best results, we recommend using Chrome or Firefox. Note: Only MP4 format is supported in Safari.');
                }
            }
            
            if (isMac && browser.chrome) {
                const chromeVersion = parseInt(navigator.userAgent.match(/Chrome\/([0-9]+)/)?.[1] || '0');
                if (chromeVersion < 72) {
                    alert('Please update Chrome to version 72 or higher for better screen recording support.');
                }
            }
        }

        // Call this when the page loads
        document.addEventListener('DOMContentLoaded', checkBrowserCompatibility);

        document.querySelector('.close-video-btn').addEventListener('click', () => {
            const playbackVideo = document.getElementById('playbackVideo');
            const videoContainer = document.getElementById('videoContainer');
            const videoTitle = document.querySelector('.video-title');
            
            playbackVideo.src = ''; // Clear the source
            playbackVideo.style.display = "none";
            videoContainer.classList.remove('active');
            videoTitle.classList.remove('active');
            document.querySelector('.video-controls').classList.remove('active');
            
            // Remove playing state from all history items
            document.querySelectorAll('.history-item').forEach(item => {
                item.classList.remove('playing');
            });
        });

        // Add this function after the playRecording function
        function downloadRecording(id) {
            const transaction = db.transaction(['recordings'], 'readonly');
            const store = transaction.objectStore('recordings');
            const request = store.get(id);

            request.onsuccess = () => {
                const recording = request.result;
                if (recording) {
                    const a = document.createElement("a");
                    a.href = URL.createObjectURL(recording.blob);
                    a.download = recording.filename;
                    a.click();
                    URL.revokeObjectURL(a.href);
                }
            };
        }
    </script>
</body>
</html>
